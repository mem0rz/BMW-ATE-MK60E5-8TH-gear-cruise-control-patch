此修改属于安全层级的修改，责任自负。项目不承担任何责任，使用项目产生的任何后果由使用人自行承担。
此修改属于安全层级的修改，责任自负。项目不承担任何责任，使用项目产生的任何后果由使用人自行承担。
此修改属于安全层级的修改，责任自负。项目不承担任何责任，使用项目产生的任何后果由使用人自行承担。

解决 DSC 固件在 8挡时巡航会退出的问题，并避免因此触发 ISTA 历史报码 5E62
现象

    进入 8 挡后巡航立刻退出。
    ISTA 里留下历史报码 5E62（群友反馈）。

固件/装载要点（用于复现）

    固件文件：6862873A111.bin，16MB；有效镜像从 file offset=0x3AC 开始。
    ROM 映射：
        ROM base = 0x00400000
        ROM size = 0x00100000
    地址换算：file_off = (EA - 0x00400000) + 0x3AC
    VM/脚本：DSC 内大量逻辑是 16-bit token 的字节码（A7/B7/E0/E8/F0/20/21/24/25/97/…）。

核心变量：slot[0x0C]（巡航判断用的“挡位/状态码”）

巡航相关脚本块中存在明显的：

    A70C：读取 slot[0x0C]
    B7xx：按值分支（case/compare）

全 ROM 中“真正对 slot0C==0x0B 做分支”的位置很少，最终收敛到 6 处，其中包含巡航退出点。
1D2（0x01D2）相关链路：挡位/状态码如何进入 DSC
入口：0x4541AC（ctx=0078，sig=7CE0）

在 1D2 链路中定位到唯一的“抽取→落地”模式：

    0x4541AC: 25F0 0078（选择上下文/消息缓存）
    0x4541B0: 25F0 7CE0（抽取某字段/信号句柄）
    0x4541BC: 9720
    0x4541BE: 970C  ← 将当前值落地到 slot0C（同时也写 slot20）

9720 970C 这种“同源连写”全 ROM 仅此一次，且位于 1D2-chain 中，可视为 slot0C 的主输入来源之一。
巡航退出的直接原因（无需猜测）
巡航判断点：0x4DA3AC 块内

该块对 slot0C 只做了少数 case，其中：

    slot0C == 0x0B → 走快速结束路径（立即 return）
        分支点：0x4DA4C8: B70B
        后续：2070 0068 21F0 00CF（快速返回）
    slot0C == 0x0C → 走另一条分支（不是这个快退）

因此现象等价于：8挡时 slot0C 变成了 0x0B，命中 B70B 快退分支。

（是否“8挡=0x0B”的枚举映射由车型/标定决定；但固件确实是按 ==0x0B 做处理，不是 >=8 之类范围判断。）
ISTA 5E62 的固件证据链
DTC 表：0x4E7080 附近

固件中存在结构化表项：

    202A 5E62 0200 0000 0000 0002

即：监测/事件ID = 0x202A → DTC = 5E62（静态表项，u16 5E62 仅此一处）。
触发点（与 0x0B 门槛强相关）

在 ctx=0079 段（包含 0x202A）中发现对 0x0B 的显式门槛：

    0x4C5ADA: 202A（监测ID）
    0x4C5B46: A90B
    0x4C5B52: B90B

该段是 5E62 触发逻辑的一部分，且明确把 0x0B 当边界值参与判断。8挡/0x0B 出现时，容易触发该监测，从而留下 ISTA 历史报码。
补丁策略（不新增 case，只改常量/已有分支）
Patch 1：修正 5E62 触发门槛（推荐先做）

目标：让 0x0B 不再命中该监测门槛（将边界从 0x0B 挪到 0x0C）。

修改 2 个 halfword：

    0x4C5B46: A90B → A90C
    0x4C5B52: B90B → B90C

对应 0pa/offset（按 file_off = (EA-0x400000)+0x3AC）：

    0x0C5EF2: A9 0B → A9 0C
    0x0C5EFE: B9 0B → B9 0C

Patch 2：修正巡航退出（交换两个 case，避免新增逻辑）

目标：不再对 slot0C==0x0B 走快退分支（同时把快退分支挪给 0x0C；若不关心 9 挡行为可接受）。

交换两处 halfword（2字节×2）：

    0x4DA4AA: B70C → B70B
    0x4DA4C8: B70B → B70C

对应 0pa/offset：

    0x0DA856: B7 0C → B7 0B
    0x0DA874: B7 0B → B7 0C

0pa（Intel HEX）补丁方式与校验

.0pa 是 Intel HEX：

    每行末尾自带 1-byte checksum，修改数据后必须重算，否则 WinkFP/解析器会拒绝。
    本文提供的脚本会：
         按绝对地址定位数据记录（支持 type 02/04 base）
         校验旧字节一致性（不匹配直接报错退出）
         写入新字节
         重新计算每行 Intel HEX checksum

Python3（Debian）补丁脚本说明

脚本输入：原始 .0pa
输出：打补丁后的 .0pa（已重算行校验）

补丁点包含：

    DTC 5E62 门槛：A90B/B90B → A90C/B90C
    巡航：交换 B70B/B70C

（脚本实现略，见仓库 patch_0pa.py。）
验证建议（刷写前/后）

    刷写前：对比 4 个 offset 位置的字节是否按预期修改。
    刷写后台架验证：
         8挡是否仍会退出巡航
         ISTA 是否仍出现 5E62 历史报码
         巡航激活后踩刹车/取消是否能正常退出（必测）

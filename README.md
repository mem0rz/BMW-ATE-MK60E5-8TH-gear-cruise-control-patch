解决 DSC 固件在 8挡时巡航会退出的问题，并避免因此触发 ISTA 历史报码 5E62；补丁尽量小、可回滚、风险可控（不影响刹车/取消等安全退出路径）。
此修改属于安全层级的修改，责任自负。项目不承担任何责任，使用项目产生的任何后果由使用人自行承担。
1) 固件装载与地址体系（基础坐实）

    固件文件 6862873A111.bin 16MB，但有效镜像从 file offset 0x3AC 开始，ROM 映射：
        ROM base 0x00400000，size 0x00100000
    地址换算已验证：
    file_off = (EA - 0x00400000) + 0x3AC
    IDA 以 PPC/MP C55xx Big Endian + VLE 载入。

2) 核心发现：DSC 内大量逻辑是 16-bit token 的“脚本/VM”

    在关键区域并非 PPC 指令，而是一套 16-bit token：
        A7xx：读 slot/变量
        B7xx：按值分支（case）
        00CF：段结束/return
        25F0：与 CAN/上下文绑定的取值动作（信号抽取）
    因此分析方法从“反汇编指令”转为“按 token 流切段 + 数据流/分支逻辑追踪”。

3) 问题定位：巡航退出条件是 slot0C == 0x0B

    在巡航相关 VM 段（0x004DA3AC）定位到典型结构：
        A70C 读取 slot[0x0C]
        B70B 分支后立即出现 ... 21F0 00CF 的快速返回块（FAST_EXIT）
    进一步用“last A7==0x0C”追踪消噪，确认全 ROM 真正是 slot0C==0x0B 分支的点只有 6 处，而 巡航段是唯一一个“命中就立刻退出”的点。
    巡航段统计结果：slot0C 的 case 只出现 0x0B/0x0C，不是 “>=8” 之类范围判断。

4) 上游来源追踪：slot0C 来自 EGS/变速箱上下文并被多链路规整

    找到 slot0C 的关键写入点 970C，并通过特征模式锁定：
        唯一一次 9720 970C 连写（同源落地）出现在 0x4541BC
        前置 token：25F0 0078 + 25F0 7CE0 → 随后落地写 slot20/slot0C
    发现 slot0C 并非只有一条写入路径：
        ctx=0078 的直解码链路（含 25F0 7CE0）
        ctx=0079 的规整/门控链路（0x492A96）：有门槛 8C0B，失败则跳过 970C/970B 写入（不更新状态）
    这些解释了“8挡时 slot0C 落到 0x0B 并触发退出”的系统性原因：不仅巡航策略盯 0x0B，上游规整也把 0x0B 当边界。

5) ISTA 报错定位：5E62 对应监测ID 0x202A，且监测逻辑对 0x0B 有明确门槛

    在 ROM 中唯一命中 0x5E62，并解析到规则表项：
        202A → 5E62
    找到 202A 的三处“非表项使用点”，其中 ctx=0079 的触发段位于 0x4C59C8..0x4C5BD2，内部明确出现：
        A90B、B90B（显式把 0x0B 当门槛）
    说明 8挡（0x0B）不仅会导致巡航退出，也更容易触发 202A 监测从而在 ISTA 留历史报码 5E62。

6) 补丁设计原则与选择
设计原则

    不新增 case/不插入新 VM 指令（避免破坏段结构、跳转、对齐）
    只改少量 16-bit 常量或对调 case token（可回滚、风险可控）
    优先解除报码（不影响驾驶行为），再处理巡航退出

本次补丁内容（两部分）

     故障码侧（监测202A/5E62）：把门槛从 0x0B 挪到 0x0C  
        0x4C5B46: A90B→A90C  
        0x4C5B52: B90B→B90C
     巡航侧（退出条件）：对调 B70B/B70C，使 slot0C==0x0B 不再走 FAST_EXIT  
        0x4DA4AA: B70C→B70B  
        0x4DA4C8: B70B→B70C

补丁通过脚本对 .0pa（Intel HEX）进行修改并重算每行 checksum，适配 WinkFP 刷写流程；ECU 内部是否存在额外程序 CRC/签名校验需刷写后验证，如有再继续定位重算机制。
